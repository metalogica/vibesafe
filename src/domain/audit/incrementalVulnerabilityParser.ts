import {
  Vulnerability,
  VulnerabilitySchema,
} from '../../../convex/services/schemas';

type ParserState =
  | 'SCANNING'
  | 'FOUND_KEY'
  | 'IN_ARRAY'
  | 'IN_OBJECT'
  | 'DONE';

export interface IncrementalVulnerabilityParser {
  feed(chunk: string): Vulnerability[];
  getParsedCount(): number;
}

export function createIncrementalVulnerabilityParser(): IncrementalVulnerabilityParser {
  let state: ParserState = 'SCANNING';
  let buffer = '';
  let scanPos = 0;
  let braceDepth = 0;
  let objectStart = -1;
  let parsedCount = 0;
  let inString = false;
  let escapeNext = false;

  function stripCodeFence(): void {
    const fenceMatch = buffer.match(/^[\s]*```(?:json)?\s*\n?/);
    if (fenceMatch) {
      buffer = buffer.slice(fenceMatch[0].length);
    }
  }

  function processBuffer(): Vulnerability[] {
    const results: Vulnerability[] = [];

    for (; scanPos < buffer.length; scanPos++) {
      const char = buffer[scanPos];

      if (escapeNext) {
        escapeNext = false;
        continue;
      }

      if (char === '\\' && inString) {
        escapeNext = true;
        continue;
      }

      if (char === '"' && !escapeNext) {
        inString = !inString;
        continue;
      }

      if (inString) continue;

      switch (state) {
        case 'SCANNING': {
          const keyIndex = buffer.indexOf('"vulnerabilities"', scanPos);
          if (keyIndex !== -1) {
            state = 'FOUND_KEY';
            scanPos = keyIndex + '"vulnerabilities"'.length - 1;
          } else {
            // Key not found yet â€” wait for more data
            // Keep scanPos near the end so we re-check on next feed
            scanPos = Math.max(0, buffer.length - '"vulnerabilities"'.length);
            return results;
          }
          break;
        }

        case 'FOUND_KEY':
          if (char === '[') {
            state = 'IN_ARRAY';
          }
          break;

        case 'IN_ARRAY':
          if (char === '{') {
            braceDepth = 1;
            objectStart = scanPos;
            state = 'IN_OBJECT';
          } else if (char === ']') {
            state = 'DONE';
          }
          break;

        case 'IN_OBJECT':
          if (char === '{') {
            braceDepth++;
          } else if (char === '}') {
            braceDepth--;
            if (braceDepth === 0) {
              const objectText = buffer.slice(objectStart, scanPos + 1);
              try {
                const parsed = JSON.parse(objectText);
                const validated = VulnerabilitySchema.safeParse(parsed);
                if (validated.success) {
                  results.push(validated.data);
                  parsedCount++;
                }
              } catch {
                // Skip malformed objects
              }
              state = 'IN_ARRAY';
            }
          }
          break;

        case 'DONE':
          return results;
      }
    }

    return results;
  }

  return {
    feed(chunk: string): Vulnerability[] {
      buffer += chunk;
      if (state === 'SCANNING' && scanPos === 0) {
        stripCodeFence();
      }
      return processBuffer();
    },

    getParsedCount(): number {
      return parsedCount;
    },
  };
}
