import { describe, expect, it } from 'vitest';

import { createIncrementalVulnerabilityParser } from '@/src/domain/audit/incrementalVulnerabilityParser';

const validVuln1 = {
  category: 'authentication',
  level: 'critical',
  title: 'Hardcoded API Key',
  description: 'API key is hardcoded in source.',
  impact: 'Full account compromise',
  filePath: 'src/config.ts',
  fix: 'Use environment variables',
};

const validVuln2 = {
  category: 'injection',
  level: 'high',
  title: 'SQL Injection',
  description: 'User input not sanitized.',
  impact: 'Data breach',
  filePath: 'src/db.ts',
  fix: 'Use parameterized queries',
};

const validVuln3 = {
  category: 'xss',
  level: 'medium',
  title: 'Reflected XSS',
  description: 'User input reflected without encoding.',
  impact: 'Session hijacking',
  filePath: 'src/views/home.ts',
  fix: 'Encode output',
};

function makeResponse(vulns: object[]): string {
  return JSON.stringify({ vulnerabilities: vulns });
}

describe('createIncrementalVulnerabilityParser', () => {
  it('parses complete JSON in single chunk', () => {
    const parser = createIncrementalVulnerabilityParser();
    const json = makeResponse([validVuln1, validVuln2, validVuln3]);
    const results = parser.feed(json);
    expect(results).toHaveLength(3);
    expect(results[0].title).toBe('Hardcoded API Key');
    expect(results[1].title).toBe('SQL Injection');
    expect(results[2].title).toBe('Reflected XSS');
  });

  it('parses vulnerabilities across multiple chunks', () => {
    const parser = createIncrementalVulnerabilityParser();
    const json = makeResponse([validVuln1, validVuln2, validVuln3]);

    // Split into chunks of varying sizes
    const chunkSize = 30;
    const allResults = [];
    for (let i = 0; i < json.length; i += chunkSize) {
      const chunk = json.slice(i, i + chunkSize);
      const results = parser.feed(chunk);
      allResults.push(...results);
    }

    expect(allResults).toHaveLength(3);
    expect(allResults[0].title).toBe('Hardcoded API Key');
    expect(allResults[1].title).toBe('SQL Injection');
    expect(allResults[2].title).toBe('Reflected XSS');
  });

  it('handles markdown code fence prefix', () => {
    const parser = createIncrementalVulnerabilityParser();
    const json = '```json\n' + makeResponse([validVuln1]) + '\n```';
    const results = parser.feed(json);
    expect(results).toHaveLength(1);
    expect(results[0].title).toBe('Hardcoded API Key');
  });

  it('skips malformed vulnerability objects', () => {
    const parser = createIncrementalVulnerabilityParser();
    const invalidVuln = {
      category: 'test',
      level: 'invalid_level',
      title: 'Bad',
      description: 'Malformed',
    };
    const json = makeResponse([validVuln1, invalidVuln, validVuln2]);
    const results = parser.feed(json);
    expect(results).toHaveLength(2);
    expect(results[0].title).toBe('Hardcoded API Key');
    expect(results[1].title).toBe('SQL Injection');
  });

  it('handles escaped braces in strings', () => {
    const parser = createIncrementalVulnerabilityParser();
    const vulnWithBraces = {
      ...validVuln1,
      description: 'Use { and } in template literals like ${foo}',
    };
    const json = makeResponse([vulnWithBraces]);
    const results = parser.feed(json);
    expect(results).toHaveLength(1);
    expect(results[0].description).toBe(
      'Use { and } in template literals like ${foo}',
    );
  });

  it('returns empty array when no vulnerabilities key', () => {
    const parser = createIncrementalVulnerabilityParser();
    const results = parser.feed('{"data": "no vulnerabilities here"}');
    expect(results).toHaveLength(0);
  });

  it('getParsedCount tracks total', () => {
    const parser = createIncrementalVulnerabilityParser();
    const json = makeResponse([validVuln1, validVuln2, validVuln3]);

    const chunkSize = 40;
    for (let i = 0; i < json.length; i += chunkSize) {
      parser.feed(json.slice(i, i + chunkSize));
    }

    expect(parser.getParsedCount()).toBe(3);
  });
});
